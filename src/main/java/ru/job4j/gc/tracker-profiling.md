*Параметры jvm: -XX:+UseSerialGC -Xmx3m -Xms2m*

#### Профилирование с помощью jmap:
1. запустим программу и посмотрим текущие результаты профилирования
(кол-во объектов в памяти 70674, потребляемая память 3480480 байт)
2. добавим 1 задачу (item) в память (реализация MemTracker), посмотрим текущие результаты профилирования
(кол-во объектов в памяти 83994, потребляемая память 3881464 байт).
как видим, кол-во объектов в памяти существенно возросло. особенно много объектов было создано для работы с датой (из пакета java.time).
у нашего item есть поле с текущей датой.
3. просмотрим текущие задачи, посмотрим текущие результаты профилирования
(кол-во объектов в памяти 84198, потребляемая память 3927904 байт).
кол-во объектов немного возросло, общий объем памяти немного увеличился.
4. удалим созданную задачу выше, посмотрим текущие результаты профилирования
(кол-во объектов в памяти 78918, потребляемая память 3583848 байт). 
кол-во объектов заметно уменьшилось, общий объем памяти уменьшился.
5. попробуем выйти за пределы памяти, добавив большое кол-во задач (item), например 100 000.
для этого в методе main в цикле for создадим 100 000 задач с рандомным по длине названием. 
при неоднократном вызове jmap, можно наблюдать скачки потребляемой памяти от 3mb до 4mb. 
у нас стоит ограничение памяти 4mb. OOM не происходит. GC справляется. программа работает существенно медленнее, можно сделать выводы, что очень много простоев,
   т.к. при многократном вызове jmap не наблюдатеся прирост кол-ва объектов.
6. повторим попытку добиться OOM уже с добавлением 1 млн задач. OOM также не проиходит.   

#### Профилирование с помощью jconsole:
п.1 - п.4 не представляют сущестенного интереса на графике Heap Memory Usage, опустим.
5. повторим п.5, чтобы пронаблюдать колебания потреяблеямой памяти на графике. на графике наблюдаем скачки от 3mb до 4mb.
6. повторим п.6. предсказуемо наблюдаем скачки от 3mb до 4mb, однако визуально можно заметить, что скачки стали менее редкими, 
   т.е. приложение больше тормозит из-за работы GC.


